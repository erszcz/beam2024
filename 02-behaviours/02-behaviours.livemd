# 02 Behaviours

## Frequency

### Setup

This and following exercises assume that the default location is repository folder `beam2024`.

All commands should be run inside either a terminal shell (commands will beging with `$`) or inside iex shell(commands will begin with `>`).

For this segment working directory is `frequency` folder in `02-behabiours` location.

### How to start

To start the project and load all relevant modules run:

```bash
$ iex -S mix
```

### Frequency module

Module implements `process skeleton` described during presentation, that is used on multiple occasions when working with OTP components of Elixir/Erlang languages.
The process can be started by calling:

<!-- livebook:{"force_markdown":true} -->

```elixir
> Frequency.start()
```

Then use provided `allocate/0` and `deallocate/1` functions to interact with the process. To stop the processes call

<!-- livebook:{"force_markdown":true} -->

```elixir
> Frequency.stop()
```

QUESTION: What will happen if you try to start Frequency second time?

### Frequency2 and Server modules

`Server` module implements common behaviour of our `process skeleton`, it contains functions like `start/2`, `stop/1`, `init/2`, `loop/2` and `call/2`. In this module two callbacks (`init/1` and `handle/2`) are also defnied, those functions will be implemented in `Frequency2` module (or any other module using `Server` as it's behaviour). This decauples generic part (e.g. process management, listening for messages etc.) from our specific part - allocating and deallocating frequencies.

Since the logic to handle process and it's information is moved into separate module interacting with `Frequency2` module is slightly different than in the first example, namely management will be done by `Serve` module, so things like start or stop. We can still use `Frequency2` module to call `allocate/0` and `deallocate/1` function.

To start the process use:

<!-- livebook:{"force_markdown":true} -->

```elixir
> {:ok, pid} = Server.start(Frequency2, [])
```

Stoping the process:

<!-- livebook:{"force_markdown":true} -->

```elixir
> Server.stop(pid)
```

Allocating frequency:

<!-- livebook:{"force_markdown":true} -->

```elixir
Frequency2.allocate()
```

Deallocating frequency:

<!-- livebook:{"force_markdown":true} -->

```elixir
Frequency2.deallocate(10)
```

## Other uses

In this section of the lecture and exercises, we are using a process skeleton to demonstrate how to apply behaviors.

However, this is not always the primary use case. Another common use case is to establish a form of contract between different modules that implement the same functionality.

A typical example is modules that handle communication with third-party APIs. Often, we do not need or want a live API implementation when running tests, or even during development.

Your task is to create a module named `*_behaviour.ex` with 2 or 3 callbacks. Optionally, you can also implement default function specifications using defmacro and `__using__`.

In the next step, create two modules that implement the behavior defined in the previous step.
