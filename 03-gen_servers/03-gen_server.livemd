# 03 GenServer

## GenServer 1

In the folder `03-gen_server`, you will find `frequency` project with an implemented GenServer.

Start the `iex` shell inside the project by running

```bash
$ iex -S mix
```

Compare the GenServer implementation with `Frequency` and `Frequency2` modules from the previous lesson.

In the `iex` shell use the functions provided by GenServer module to interact with `Frequency` GenServer.

Start the process:

<!-- livebook:{"force_markdown":true} -->

```elixir
> {:ok, pid} = GenServer.start(Frequency, [])
```

Issue `allocate` or `deallocate` call

<!-- livebook:{"force_markdown":true} -->

```elixir
> GenServer.call(pid, :allocate)
> GenServer.call(pid, {:deallocate, 1})
```

Stop the process:

<!-- livebook:{"force_markdown":true} -->

```elixir
> GenServer.stop(pid)
```

#### Question

Is it possible to start multiple `Frequency` GenServers? If yes, why?

#### Useful tips

* You can use Observer to visually inspect the `Frequency` GenServer
  ```elixir
  > :observer.start()
  ```
* If Observer isn't working for some reason you can use `:sys.get_state/1` to get information about current state of the process
  ```elixir
  {:ok, pid} = GenServer.start(Frequency, [])
  :sys.get_state(pid)
  ```

## GenServer 2

So far when implementing GenServers we have used simple data structures (maps) to store state, but in the real world scenario state can be more complex than that, we can easily add a layer of control by passing Elixir struct as a state, then we are able to leverage more complex mechanisms to validate data or be more descriptive of what we store in the state.

#### GenServer: UserCache

In the `03-gen_server/frequency/lib` directory, create `user_cache.ex` file.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule UserCache do
  use GenServer

  @impl true
  def init(_) do
    {:ok, %{}}
  end
end
```

The state that will be stored by this process will be represented by two nested structures, frist one:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule State do
  defstruct [:amount, :users]
end
```

And user structure:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule User do
  defstruct [:id, :name]
end
```

**NOTE** Usually these structures could be more complex, could live in different directory etc. but for the sake of of the exercise we are putting them in the same module as the GenServer

Now that we have structures that will hold the state, we can update implementation of the GenServer:

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule UserCache do
  use GenServer

  defmodule User do
    defstruct [:id, :name]
  end

  defmodule State do
    defstruct [:users, :amount]
  end

  @impl true
  def init(_) do
    {:ok, %State{amount: 0, users: []}}
  end
end
```

#### Exercises

* Add `handle_call/3` implementation that will add new user to the cache, example input: `{:add, 1, "Name"}`, output: `:ok`, state modification: new user is added to the `users` list, `amount` is increased by 1
* Add `handle_call/3` to fetch current state
* Add `handle_call/3` to delete user from the cache, input: `{:remove, 1}`, output: `:ok,` state mpdification: `amount` decreased by 1, user with specified id should be removed from the `users` list
